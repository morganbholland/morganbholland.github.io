[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "1 + 1\n\n[1] 2"
  },
  {
    "objectID": "applied_research.html",
    "href": "applied_research.html",
    "title": "Applied Research",
    "section": "",
    "text": "In addition to my academic research, I work as a consultant at the FSU Center for Economic Forecasting and Analysis (CEFA). I have experience in many areas, including"
  },
  {
    "objectID": "applied_research.html#completed-projects",
    "href": "applied_research.html#completed-projects",
    "title": "Applied Research",
    "section": "Completed Projects",
    "text": "Completed Projects\n\nFlorida State’s Economic Impact. 2021 version based on 2020 data.\nThe Economic Impact of a Reduction in the Sales Tax on Manufactured Homes\nAn Economic Impact Analysis of Humana/Humana Florida Medicaid in Florida (Phase 1)"
  },
  {
    "objectID": "applied_research.html#completed-drafts",
    "href": "applied_research.html#completed-drafts",
    "title": "Applied Research",
    "section": "Completed Drafts",
    "text": "Completed Drafts\n\nThe Economic Impact of Visitors to Members of the Florida African American Historical Preservation Society\nThe Economic Impact of NASCAR operations in Florida\nThe Economic Impact of the McGriff Channel Dredging Project\nAn Economic Impact and Valuation Analysis of the Pensacola and Perdido Bays Estuary Program (PPBEP)\nAn Economic Impact Analysis of Eighteen Blueprint Projects and Three Traffic Flow Analyses"
  },
  {
    "objectID": "applied_research.html#in-progress",
    "href": "applied_research.html#in-progress",
    "title": "Applied Research",
    "section": "In Progress",
    "text": "In Progress\n\nAn Economic Impact and Valuation Analysis of the St. Andrews Bay Estuary Program"
  },
  {
    "objectID": "CV.html",
    "href": "CV.html",
    "title": "CV",
    "section": "",
    "text": "This page has links to two versions of my CV, one for academia and one for professional use.\nAcademic CV\nProfessional CV"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Morgan Holland",
    "section": "",
    "text": "Welcome to the personal website of Morgan Holland. I am an economist working for the Center for Business and Economic Analysis (CBEA) at the University of Wyoming. If you are looking to interact with me in a professional capacity, here’s the website for the CBEA.\nThe links at the top of the page will take you to pages where you can learn more about me, including my research and teaching experience, copies of my CV/resume (which may be out-of-date), and a blog where I will occasionally post about data, economics, and random coding things I do.\nI also plan on using this website as a work space to improve my website development and coding skills, so expect some dust."
  },
  {
    "objectID": "research.html",
    "href": "research.html",
    "title": "Academic Research",
    "section": "",
    "text": "Here you can find abstracts and links to some of my academic research."
  },
  {
    "objectID": "research.html#submissions",
    "href": "research.html#submissions",
    "title": "Academic Research",
    "section": "Submissions",
    "text": "Submissions\nAtolia, Manoj; Holland, Morgan; Kreamer, Jonathan. Growth, Income Distribution and Policy Implications of Automation. Submitted to the Journal of Economic Dynamics and Control.\nAbstract: We study the distributional consequences of automation in a model with two kinds of agents — workers, who supply labor, and entrepreneurs, who own capital. We assume that production involves tasks that can be done by either capital or labor with varying productivity. We conceptualize automation as a shift in the relative productivity of capital at certain tasks that reduces the set of tasks done by labor. We contrast this with “traditional technical progress”, which is an increase in capital productivity at tasks previously done by capital. We derive a simple condition that governs whether labor share goes to zero in the long run, for given tax rates. We then characterize the distributional consequences of a shift in technology, using a tractable case that allows us to cleanly distinguish between automation and traditional technological progress. Finally, we endogenize the tax rate by computing the political economy equilibrium under majority voting, where the government has access to a capital tax and a transfer to workers (a “universal basic income”). We give conditions for zero or positive capital taxation in the steady state, and conditions under which workers prefer that the labor share go to zero and they derive income wholly from the UBI. Finally, we find that moving to majority voting during an episode of automation results in much smaller additional gains for workers than entrepreneurs."
  },
  {
    "objectID": "research.html#working-papers",
    "href": "research.html#working-papers",
    "title": "Academic Research",
    "section": "Working Papers",
    "text": "Working Papers\nAtolia, Manoj; Holland, Morgan. The Welfare Benefits of Early Termination in Relationship Banking Contracts.\nAbstract: This paper explores the welfare benefits from relationship banking that arise from the information gleaned by banks through monitoring. If monitoring reveals not only current output, but also new information about future payoffs, lenders can shield themselves from future losses through early termination of lending agreements. In a competitive lending environment, banks shift the benefits of early termination to borrowers through the lending terms, improving not only the overall expected payoff of projects, but also the welfare of borrowers. Numerical results reveal that the benefits of long-term relationships based on the information revealed in monitoring could be substantial.\n\nAtolia, Manoj; Holland, Morgan; Kreamer, Jonathan. Disentangling the Impact of Automation on Wage, Wealth, and Income Inequality.\nAbstract: Changes in income inequality from advanced automation may stem from two sources. Wages may become more unequal as lower skill tasks that are currently performed by workers are done in the future by computerized capital. With higher relative wage income, high-skill workers will be able to afford investments in capital that are out of reach for low-skill workers, exacerbating income inequality further. Using a general equilibrium model of task-based production, we disentangle the impacts of automation on wage, wealth, and income inequality. For a 20% increase in output driven by automation, we predict a 70% increase in the wage premium for skilled workers and a 70.1% increase in the income premium (wages + capital income) for skilled workers, indicating that the majority of inequality from automation stems from wage inequality. Qualitatively this finding is the same for different elasticities of substitution, though quantitatively it differs somewhat. Finally, using this framework, we develop a political economy model to discuss the optimal taxing of capital in the context of increasing automation."
  },
  {
    "objectID": "research.html#works-in-progress",
    "href": "research.html#works-in-progress",
    "title": "Academic Research",
    "section": "Works in Progress",
    "text": "Works in Progress\nHolland, Margaret; Holland, Morgan. The Impact of the Americans with Disabilities Act on Employment and Earnings of People with Disabilities: An Intersectional Approach.\nAbstract: The Americans with Disabilities Act (ADA) was designed to decrease discrimination by employers against people with disabilities and thereby improve the earnings and employment of people with disabilities. Motivated by intersectionality, we use difference in differences to determine how the ADA affected disparities in employment and earnings differently for marginalized populations."
  },
  {
    "objectID": "Teaching.html",
    "href": "Teaching.html",
    "title": "Teaching",
    "section": "",
    "text": "For all the courses I teach, I have developed custom instructional materials that are constantly evolving."
  },
  {
    "objectID": "Teaching.html#econ-3431-analysis-of-economic-data",
    "href": "Teaching.html#econ-3431-analysis-of-economic-data",
    "title": "Teaching",
    "section": "Econ 3431: Analysis of Economic Data",
    "text": "Econ 3431: Analysis of Economic Data\nIn-person: Summer 2017, Summer 2019, Summer 2021\nOnline: Summer 2020\nAnalysis of Economic Data is a class designed to re-introduce students to statistical concepts they may not have seen since an introductory statistics course. This class also introduces the mathematical rigor and familiarity with statistical software necessary to succeed in an introductory course in econometrics. I ordinarily teach this class using R."
  },
  {
    "objectID": "Teaching.html#econ4421-introduction-to-econometrics",
    "href": "Teaching.html#econ4421-introduction-to-econometrics",
    "title": "Teaching",
    "section": "Econ4421: Introduction to Econometrics",
    "text": "Econ4421: Introduction to Econometrics\nIn-person: Summer 2018\nOnline: Spring 2020\nTA: Fall 2020\nThis course introduces students to causal inference with data. In particular, the class focuses primarily on a rigorous look at multiple linear regression and the Gauss-Markov theorem. Once established, this class also examines common failures of the assumptions in the Gauss-Markov theorem and ways to account for them, including nonlinearity, heteroskedasticity, serial correlation, simple forms of endogeneity, and multicolinearity. I ordinarily demonstrate these concepts to students using R."
  },
  {
    "objectID": "Teaching.html#ecp3113-economics-of-population",
    "href": "Teaching.html#ecp3113-economics-of-population",
    "title": "Teaching",
    "section": "ECP3113: Economics of Population",
    "text": "ECP3113: Economics of Population\nTA: Fall 2020"
  },
  {
    "objectID": "Teaching.html#eco3223-financial-markets-banking-and-monetary-policy",
    "href": "Teaching.html#eco3223-financial-markets-banking-and-monetary-policy",
    "title": "Teaching",
    "section": "ECO3223: Financial Markets, Banking, and Monetary Policy",
    "text": "ECO3223: Financial Markets, Banking, and Monetary Policy\nTA: Fall 2019"
  },
  {
    "objectID": "Teaching.html#testimonials-from-students",
    "href": "Teaching.html#testimonials-from-students",
    "title": "Teaching",
    "section": "Testimonials from Students",
    "text": "Testimonials from Students\n“Morgan Holland is the best instructor I have had for an economics core class. His lectures helped me understand the material, and he really seems to care about his students and wants them to pass.”\n“Holland’s availability and willingness to always help his students is what has allowed me to better comprehend the material. He always goes above and beyond to make sure students are able to have access to resources”"
  },
  {
    "objectID": "blog/listing.html",
    "href": "blog/listing.html",
    "title": "Blog",
    "section": "",
    "text": "I don’t expect this to be updated frequently, but I thought I would include some blog posts here about some of the data work and other analysis I’ve done.\n\n\n\n\n\n\n\n\n\n\nIdentifying Counties that Contain the St. Andrews Bay Watershed\n\n\n\n\n\n\n\ngis\n\n\npython\n\n\nanalysis\n\n\n\n\nSome simple GIS with Python\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nNo matching items"
  },
  {
    "objectID": "blog/posts/mapping.html",
    "href": "blog/posts/mapping.html",
    "title": "Identifying Counties that Contain the St. Andrews Bay Watershed",
    "section": "",
    "text": "This document steps through the process and Python code needed to identify the counties in Florida that contain the St. Andrews Bay Watershed. This document assumes some knowledge of doing GIS work with GeoPandas in Python. If you don’t know anything about GeoPandas, you can learn more at Geocomputation with R. This is the online textbook for a course in GIS using GeoPandas from the University of Helsinki.\nFor more information about programming Python in general, I recommend Automate the Boring Stuff with Python.\nAdditionally, I recommend installing the Anaconda distribution of Python, as it will come with MatPlotLib, Pandas, Numpy, and many other useful packages for data science/analysis. You can find the Anaconda distribution of Python at their website.\nFinally, this document was created as a Jupyter Notebook. For more information about Jupyter Notebooks, click here"
  },
  {
    "objectID": "blog/posts/mapping.html#loading-packages-and-data",
    "href": "blog/posts/mapping.html#loading-packages-and-data",
    "title": "Identifying Counties that Contain the St. Andrews Bay Watershed",
    "section": "Loading Packages and Data",
    "text": "Loading Packages and Data\nThe first step is to import some necessary packages:\n\nimport geopandas as gpd\nimport matplotlib.pyplot as plt\n\nIf you have not already installed geopandas and matplotlib, install them using\nconda install geopandas\nconda install matplotlib\nin the terminal.\nNext, we need to load a GIS file that contains the county boundaries. I prefer the county map with detailed shorelines that can be downloaded by clicking this link.\nOnce downloaded, unzip this folder into a subdirectory in the same folder as this .ipynb file. I created a folder called “mapping_data.” for this purpose. We load the counties using the following commands:\n\ncounties_file = \"mapping_data\\countyshore_areas_sep15.shp\" #define the name of the file\ncounties = gpd.read_file(counties_file) #load the file.\n#Note that you can also simpy do \n#counties = gpd.read_file(\"countyshore_areas_sep15.shp\")\n\nNext, we examine the first 5 lines of the data to make sure it looks ok.\n\ncounties.head()\n\n\n\n\n\n  \n    \n      \n      STATEFP\n      COUNTYFP\n      COUNTYNS\n      GEOID\n      NAME\n      NAMELSAD\n      LSAD\n      CLASSFP\n      MTFCC\n      CSAFP\n      ...\n      ALAND\n      AWATER\n      INTPTLAT\n      INTPTLON\n      DESCRIPT\n      FGDLAQDATE\n      AUTOID\n      SHAPE_AREA\n      SHAPE_LEN\n      geometry\n    \n  \n  \n    \n      0\n      None\n      None\n      None\n      None\n      WATER\n      WATER\n      None\n      None\n      None\n      None\n      ...\n      0.000000e+00\n      0.0\n      None\n      None\n      WATER\n      2015-09-24\n      1\n      2.701470e+10\n      4.507754e+07\n      MULTIPOLYGON (((267492.080 663494.650, 267492....\n    \n    \n      1\n      12\n      053\n      00295751\n      12053\n      HERNANDO\n      HERNANDO COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      1.224611e+09\n      300943246.0\n      +28.5730426\n      -082.4662272\n      HERNANDO\n      2015-09-24\n      2\n      1.265956e+09\n      5.228369e+05\n      MULTIPOLYGON (((551025.130 521907.140, 553442....\n    \n    \n      2\n      12\n      129\n      00306912\n      12129\n      WAKULLA\n      WAKULLA COUNTY\n      06\n      H1\n      G4020\n      533\n      ...\n      1.570621e+09\n      334901394.0\n      +30.1403575\n      -084.3751122\n      WAKULLA\n      2015-09-24\n      3\n      1.581877e+09\n      8.698931e+05\n      MULTIPOLYGON (((379858.150 679741.650, 379842....\n    \n    \n      3\n      12\n      131\n      00295727\n      12131\n      WALTON\n      WALTON COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      2.687690e+09\n      522844944.0\n      +30.6312106\n      -086.1766139\n      WALTON\n      2015-09-24\n      4\n      2.753186e+09\n      7.321848e+05\n      MULTIPOLYGON (((172458.210 778412.420, 172914....\n    \n    \n      4\n      12\n      127\n      00306921\n      12127\n      VOLUSIA\n      VOLUSIA COUNTY\n      06\n      H1\n      G4020\n      422\n      ...\n      2.851714e+09\n      858278452.0\n      +29.0577690\n      -081.1617920\n      VOLUSIA\n      2015-09-24\n      5\n      2.923794e+09\n      2.026974e+06\n      MULTIPOLYGON (((696125.960 562367.650, 696123....\n    \n  \n\n5 rows × 23 columns\n\n\n\nThe first row (after the column names) defines the water areas. All the other rows are counties. Let’s plot it to make sure it looks right:\n\ncounties.plot(figsize = (10,8))\n\n<AxesSubplot:>\n\n\n\n\n\nThis is a very basic plot. We can add more bells and whistles later if we want to. We just wanted to make sure all the county boundaries are there. Which it looks like they are.\nThe next step is to load the watershed data. This was provided by the Saint Andrew and Saint Joseph Bay Estuary Program. I’ll use the same steps as I did in loading the county data.\n\nbay_file = \"mapping_data\\St_Andrew_Bay_Watershed.shp\"\n\nbay = gpd.read_file(bay_file)\n#Note again that it's perfectly fine to simply do\n#bay = gpd.read_file(\"St_Andrew_Bay_Watershed.shp\")\n\nAgain, let’s examine the first five rows:\n\nbay.head()\n\n\n\n\n\n  \n    \n      \n      WATERSHED\n      SQMILES\n      ACRES\n      Label\n      Shape_Leng\n      Shape_Area\n      geometry\n    \n  \n  \n    \n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n      MULTIPOLYGON (((657728.080 3285899.015, 657752...\n    \n  \n\n\n\n\nHere we see that this dataset is actually just a single observation. That’s fine. All the data we need is contained in the geometry column. Let’s plot it to see what it looks like:\n\nbay.plot(figsize = (10,8))\n\n<AxesSubplot:>\n\n\n\n\n\nAgain, this plot is very basic, but all we wanted to see is that the watershed appears to be defined correctly."
  },
  {
    "objectID": "blog/posts/mapping.html#harmonizing-data",
    "href": "blog/posts/mapping.html#harmonizing-data",
    "title": "Identifying Counties that Contain the St. Andrews Bay Watershed",
    "section": "Harmonizing Data",
    "text": "Harmonizing Data\nNow that we have the two datasets loaded, we need to harmonize their CRS’s in order to work with them. A CRS, or coordinate reference system, refers to the way the geometric objects are projected onto a map. For more information on CRS’s and working with them in GeoPandas, see Lesson 3 from Geocomputation with R.\nLet’s look at the CRS’s of both datasets:\n\nbay.crs\n\n<Projected CRS: EPSG:26916>\nName: NAD83 / UTM zone 16N\nAxis Info [cartesian]:\n- E[east]: Easting (metre)\n- N[north]: Northing (metre)\nArea of Use:\n- name: North America - 90°W to 84°W and NAD83 by country\n- bounds: (-90.0, 23.97, -84.0, 84.0)\nCoordinate Operation:\n- name: UTM zone 16N\n- method: Transverse Mercator\nDatum: North American Datum 1983\n- Ellipsoid: GRS 1980\n- Prime Meridian: Greenwich\n\n\n\ncounties.crs\n\n<Projected CRS: PROJCS[\"Albers Conical Equal Area [Florida Geograp ...>\nName: Albers Conical Equal Area [Florida Geographic Data Library]\nAxis Info [cartesian]:\n- [east]: Easting (metre)\n- [north]: Northing (metre)\nArea of Use:\n- undefined\nCoordinate Operation:\n- name: unnamed\n- method: Albers Equal Area\nDatum: NAD83 (High Accuracy Reference Network)\n- Ellipsoid: GRS 1980\n- Prime Meridian: Greenwich\n\n\nAs you can see, they do not use the same projection. Therefore, we’ll have to convert one to the other. The easiest way to do this is to change the CRS of the counties object.\n\ncounties_proj = counties.copy() #create a new dataset that is a copy of counties. \n                                # This allows us to modify the data without affecting the original. \ncounties_proj = counties_proj.to_crs(epsg=26916) #change the projection\n\nLet’s check the projection of the counties_proj object to make sure it matches the watershed.\n\ncounties_proj.crs\n\n<Projected CRS: EPSG:26916>\nName: NAD83 / UTM zone 16N\nAxis Info [cartesian]:\n- E[east]: Easting (metre)\n- N[north]: Northing (metre)\nArea of Use:\n- name: North America - 90°W to 84°W and NAD83 by country\n- bounds: (-90.0, 23.97, -84.0, 84.0)\nCoordinate Operation:\n- name: UTM zone 16N\n- method: Transverse Mercator\nDatum: North American Datum 1983\n- Ellipsoid: GRS 1980\n- Prime Meridian: Greenwich\n\n\nAs a final check, we can plot it again to see if it looks right.\n\ncounties_proj.plot(figsize = (10,8))\n\n<AxesSubplot:>\n\n\n\n\n\nSeems fine to me."
  },
  {
    "objectID": "blog/posts/mapping.html#determining-the-relevant-counties.",
    "href": "blog/posts/mapping.html#determining-the-relevant-counties.",
    "title": "Identifying Counties that Contain the St. Andrews Bay Watershed",
    "section": "Determining the Relevant Counties.",
    "text": "Determining the Relevant Counties.\nOne simple way to determine which counties contain part of the watershed is to simply show them in the same plot.\n\nfig, ax = plt.subplots(figsize = (10,8)) #define an emplty plot that we will fill with the two datasets\n\nbay.geometry.boundary.plot(color=None, edgecolor='b', linewidth=0.5, ax=ax) #plot only the watershed borders. No fill.\ncounties_proj.geometry.boundary.plot(color=None, edgecolor='k', linewidth=0.5, ax=ax) #plot only the county borders. No fill.\n\n<AxesSubplot:>\n\n\n\n\n\nIt would not be hard at this point to simply look at a county map of Florida and get the names of the counties that contain the watershed. However, since we may want to do some further analysis of the counties and we may want to produce some nicer figures of the bay area, we might as well filter the data to contain only counties that overalp with the watershed.\n\nbay_counties = gpd.sjoin(counties_proj,bay)\nbay_counties.head()\n\n\n\n\n\n  \n    \n      \n      STATEFP\n      COUNTYFP\n      COUNTYNS\n      GEOID\n      NAME\n      NAMELSAD\n      LSAD\n      CLASSFP\n      MTFCC\n      CSAFP\n      ...\n      SHAPE_AREA\n      SHAPE_LEN\n      geometry\n      index_right\n      WATERSHED\n      SQMILES\n      ACRES\n      Label\n      Shape_Leng\n      Shape_Area\n    \n  \n  \n    \n      0\n      None\n      None\n      None\n      None\n      WATER\n      WATER\n      None\n      None\n      None\n      None\n      ...\n      2.701470e+10\n      4.507754e+07\n      MULTIPOLYGON (((656790.384 3316776.851, 656790...\n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n    \n    \n      3\n      12\n      131\n      00295727\n      12131\n      WALTON\n      WALTON COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      2.753186e+09\n      7.321848e+05\n      MULTIPOLYGON (((558825.154 3429125.747, 559281...\n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n    \n    \n      18\n      12\n      013\n      00306919\n      12013\n      CALHOUN\n      CALHOUN COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      1.487458e+09\n      1.920278e+05\n      POLYGON ((680521.151 3387596.693, 680746.153 3...\n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n    \n    \n      33\n      12\n      005\n      00295738\n      12005\n      BAY\n      BAY COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      1.992719e+09\n      1.132443e+06\n      MULTIPOLYGON (((647799.345 3382670.805, 647815...\n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n    \n    \n      54\n      12\n      063\n      00295734\n      12063\n      JACKSON\n      JACKSON COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      2.468557e+09\n      2.267942e+05\n      POLYGON ((669268.534 3431030.466, 670890.596 3...\n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n    \n  \n\n5 rows × 30 columns\n\n\n\nNotice that the first observation in this dataset is named “WATER.” This is the observation that holds all the water features in Florida. We need to get rid of this observation or any figures we try to produce will contain the whole coastline of Florida. You can try this out by running\nbay_counties.plot()\nif you want. So next we’ll drop the “WATER” observation:\n\nbay_counties = bay_counties[bay_counties[\"NAME\"] != \"WATER\"]\nbay_counties.head(7)\n\n\n\n\n\n  \n    \n      \n      STATEFP\n      COUNTYFP\n      COUNTYNS\n      GEOID\n      NAME\n      NAMELSAD\n      LSAD\n      CLASSFP\n      MTFCC\n      CSAFP\n      ...\n      SHAPE_AREA\n      SHAPE_LEN\n      geometry\n      index_right\n      WATERSHED\n      SQMILES\n      ACRES\n      Label\n      Shape_Leng\n      Shape_Area\n    \n  \n  \n    \n      3\n      12\n      131\n      00295727\n      12131\n      WALTON\n      WALTON COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      2.753186e+09\n      7.321848e+05\n      MULTIPOLYGON (((558825.154 3429125.747, 559281...\n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n    \n    \n      18\n      12\n      013\n      00306919\n      12013\n      CALHOUN\n      CALHOUN COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      1.487458e+09\n      1.920278e+05\n      POLYGON ((680521.151 3387596.693, 680746.153 3...\n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n    \n    \n      33\n      12\n      005\n      00295738\n      12005\n      BAY\n      BAY COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      1.992719e+09\n      1.132443e+06\n      MULTIPOLYGON (((647799.345 3382670.805, 647815...\n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n    \n    \n      54\n      12\n      063\n      00295734\n      12063\n      JACKSON\n      JACKSON COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      2.468557e+09\n      2.267942e+05\n      POLYGON ((669268.534 3431030.466, 670890.596 3...\n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n    \n    \n      58\n      12\n      133\n      00295762\n      12133\n      WASHINGTON\n      WASHINGTON COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      1.595316e+09\n      2.404198e+05\n      POLYGON ((643879.684 3411685.915, 643992.119 3...\n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n    \n    \n      64\n      12\n      045\n      00306917\n      12045\n      GULF\n      GULF COUNTY\n      06\n      H1\n      G4020\n      None\n      ...\n      1.449020e+09\n      5.837829e+05\n      MULTIPOLYGON (((656790.384 3316776.851, 656779...\n      0\n      St. Andrew Bay\n      1156.573241\n      740209.835244\n      4.0\n      1.315842e+06\n      2.995523e+09\n    \n  \n\n6 rows × 30 columns\n\n\n\nThe “WATER” observation has indeed been dropped.\nLet’s plot the area again with the watershed superimposed on the counties. This time, I’ll add county names. Adding the county names is a somewhat complicated procedure, so I’ll step through it carefully. The first thing I need to do is use the representative_point method from the shapely package. GeoPandas uses the shapely package to manage geometric shapes, so there’s no need to load it separately. The representative_point method computes a point that is guaranteed to be within a polygon. That’s the point at which I will place the county names. I could also use the centroid method to find the “center of gravity” of each county, but that method is computationally more expensive, so I will stick with representative_point.\n\n#Compute a new variable called 'coords'. The variable is computed by applying the representative point method to each county,\n#then extracting the resulting coordinates.\nbay_counties['coords'] = bay_counties['geometry'].apply(lambda x: x.representative_point().coords[:])\nbay_counties['coords'] = [coords[0] for coords in bay_counties['coords']]\n\nOnce I have representative points for each county, the next step is to show the counties and the watershed on the same plot, then add in the names at each representative point in coords.\n\nfig, ax = plt.subplots(figsize = (10,8)) #Define an empty figure\n\nbay.plot(color='b', edgecolor='k',alpha=0.5, ax=ax) #Put the watershed boundaries into the empty figure. This time I will use a \n                                                    #transparent blue as a fill.\nbay_counties.geometry.boundary.plot(color=None, edgecolor='k', linewidth=0.5, ax=ax) # Plot the county borders\n\n#The for loop below plots the county names at the coordinates specified by the coords variable.\nfor idx, row in bay_counties.iterrows():\n    ax.text(row.coords[0], row.coords[1], s=row['NAME'], size='smaller',\n            horizontalalignment='center', bbox={'facecolor':'white', 'alpha':0, 'pad': 2, 'edgecolor':'none'\n                                               })\n\n\n\n\nHere we can easily see which counties overlap with the watershed.\nFinally, we want to determine how much of the watershed is in each county. In other words, we want to compare the area of the intersection of each county with the watershed with the total area of the watershed. The first step in doing so is to make a new variable for the portion of each county that is part of the watershed.\n\nbay_counties['Watershed'] = bay_counties.geometry.apply(lambda x: x.intersection(bay.geometry[0]))\n\n\nbay_counties['Watershed'].plot(facecolor = \"none\", edgecolor = 'k', figsize = (10,8))\n\n<AxesSubplot:>\n\n\n\n\n\nNext, we make a new variable that calculates the area of the Watershed variable. The CRS uses meters as its distance unit, so areas will be in square meters.\n\nbay_counties['Watershed_Area']=bay_counties.Watershed.area\n\nFinally, we make a variable that calculates the percentage of the watershed area in each county:\n\nbay_counties['Watershed_Proportion']=bay_counties.Watershed_Area/bay_counties.Watershed_Area.sum()*100\n\nI can print a table of the percentage of the watershed in each county by selecting the NAME and Watershed_Proportion columns\n\nbay_counties[['NAME','Watershed_Proportion']]\n\n\n\n\n\n  \n    \n      \n      NAME\n      Watershed_Proportion\n    \n  \n  \n    \n      3\n      WALTON\n      2.465263\n    \n    \n      18\n      CALHOUN\n      3.708971\n    \n    \n      33\n      BAY\n      61.935065\n    \n    \n      54\n      JACKSON\n      2.461653\n    \n    \n      58\n      WASHINGTON\n      9.570461\n    \n    \n      64\n      GULF\n      19.858587\n    \n  \n\n\n\n\nJust as a check, we will make sure the percentages add up to 100.\n\nbay_counties.Watershed_Proportion.sum()\n\n100.0\n\n\nThe final task I’d like to accomplish in this document is to export the watershed proportion table to Excel for formatting.\n\nfrom pandas import ExcelWriter\n\n\nwriter = ExcelWriter(\"Watershed.xlsx\", engine='xlsxwriter')\nbay_counties[['NAME', 'Watershed_Area', 'Watershed_Proportion']].to_excel(writer, sheet_name='data',index=False)\nwriter.save()\n\nA lot more GIS work can be done in Python, and in a future post I hope to introduce some of the other work that is being done on the economic value of the St. Andrew Bay Watershed, but we’ll leave it off here for now."
  },
  {
    "objectID": "about_me.html",
    "href": "about_me.html",
    "title": "About Me",
    "section": "",
    "text": "I am a PhD Economist with a rich background in providing answers to questions using economic and statistical analysis.\n\nBiography\nI earned a B.S. in Business Administration from Mississippi College in 2010 before working as an accountant for the State of Mississippi. I later worked as an auditor for the State of South Carolina Office of Regulatory Staff (ORS) where I reviewed rate increase requests from public utility companies and completed regulatory compliance audits. I left ORS in 2012 to pursue a Master’s in Applied Economics from the University of South Carolina Moore School of Business, which I received in 2014.\nI graduated with a PhD in Economics from Florida State University in July of 2022. My academic research interests included economic growth and inequality, the economics of automation, contracting with financial frictions, and the economics of disability. I have a rich background in economic theory and application, with experience in applied econometrics, DSGE and macroeconomic growth modeling, numerical methods, public utility regulation and compliance, modeling corporate financial decisions, and disability research.\nIn addition to my academic research, I am also an applied economist who uses insights from data and economic analysis to assist clients in planning, decision making, and advocacy. Examples of recent projects include analyzing the effects of a reduction in tax rates on manufactured homes, evaluating the economic impacts of road developments, and economic impact analyses of various firms operating in Florida.\nI began working for the Center for Business and Economic Analysis (CBEA) at the University of Wyoming in January of 2023 as a Senior Research Economist. My primary focus at CBEA is the tourism and hospitality sectors in Wyoming. I am especially interested in researching and promoting policies that will help Wyoming take full advantage of its outdoor recreation resources while preserving them for future generations. I also provide support services to stakeholders in the tourism and hospitality sector through economic research and analysis."
  },
  {
    "objectID": "blog/posts/horners_method.html",
    "href": "blog/posts/horners_method.html",
    "title": "Numerical Methods in Economics AKA the Horner Algorithm",
    "section": "",
    "text": "using LinearAlgebra\nAs a side project from my usual work, I’m brushing up on both my Julia programming and my numerical methods by writing and explaining some of the main algorithms from Judd’s Numerical Methods in Economics. It’s a rather dated book, but the basic algorithms haven’t changed any since then."
  },
  {
    "objectID": "blog/posts/horners_method.html#horners-method-for-efficient-polynomial-evaluation",
    "href": "blog/posts/horners_method.html#horners-method-for-efficient-polynomial-evaluation",
    "title": "Numerical Methods in Economics AKA the Horner Algorithm",
    "section": "Horner’s Method for Efficient Polynomial Evaluation",
    "text": "Horner’s Method for Efficient Polynomial Evaluation\nThe first algorithm we come across in this book is a method for efficiently evaluating polynomials. This is more of a pedagogical tool since any proper compiler will implement this method already. The lesson that should be taken from this notebook is to think carefully about your problem and see if you can reformulate it in such a way that the number of computations needed is smaller.\nThe Horner algorithm is the most efficient method for evaluating polynomials of n degrees, requiring n additions and n multiplications. Consider the polynomial \\(1 + 2x + 3x^2 + 4x^3 + 5x^4\\). Suppose we want to evaluate this polynomial when x = 5. We can compute the answer directly in Julia like so:\n\npolyeval(x) = 1 + 2*x + 3*x^2 + 4*x^3 + 5*x^4\npolyeval(5)\n\n#Note: You don't have to do this in a function, you could simply do\n# 1 + 2*5 + 3*5^2 + 4*5^3 + 5*5^4\n# But Julia's JIT compiler makes it worthwhile to get into the habit of writing functions for most things. \n\n3711\n\n\nFor small-order polynomials, this is perfectly acceptable. But notice that in order to compute this directly, we needed to to perform \\(n-1\\) exponentiations, \\(n\\) multiplications, and \\(n\\) additions. We can decrease the computational burden significantly by employing Horner’s algorithm. Suppose we factor our polynomial like so: \\[1 + 2x + 3x^2 + 4x^3 + 5x^4 = 1 + x(2 + x(3 + x(4 + x \\cdot 5)))\\] Now we only need to perform \\(n\\) multiplications and \\(n\\) additions. The following function implements Horner’s algorithm in Julia:\n\nhorner = function(x, coef)\n    out = coef[end] # in Julia, variables created in a loop are local to that loop. So we do the first part of the evaluation outside the loop. \n    for i in reverse(1:length(coef)-1) # iteratively evaluate the factorized polynomial. \n        out = coef[i] + x*out\n    end\n    return out\nend\n\n#11 (generic function with 1 method)\n\n\nThe function takes a vector of coefficients coef and a base x and performs Horner’s algorithm to calculate the result. Let’s verify that it works using our example polynomial:\n\nx = 5\ncoef = [1, 2, 3, 4, 5]\n\n5-element Vector{Int64}:\n 1\n 2\n 3\n 4\n 5\n\n\n\nhorner(x,coef)\n\n3711\n\n\nThe function does indeed return the correct answer. As a bonus, let’s time both functions to see which one is faster. To do so, we’ll need to modify both functions slightly.\n\npolyevaltimed(x, coef) = @time dot(coef, [x^(i-1) for i in 1:length(coef)]) # This is simply representing the polynomial as the dot product of a vector of coefficients and a vector of powers of x.\n\nhornertimed(x, coef) = @time horner(x, coef)\n\nhornertimed (generic function with 1 method)\n\n\n\nprintln(polyevaltimed(5, coef))\nprintln(hornertimed(5,coef))\n\n  0.000002 seconds (1 allocation: 96 bytes)\n3711\n  0.000005 seconds (1 allocation: 16 bytes)\n3711\n\n\nWhat’s this? Why is the horner function slower? Let’s try a much bigger polynomial.\n\ncoefbig = rand(Int,1000)\n\n1000-element Vector{Int64}:\n -3492488395655115368\n  2464457242624337555\n -5662513376974913452\n -1510065389810720230\n   177958511545418563\n -2548246649911588339\n  8053889577345754314\n -2993736192672319341\n -5990236018147147910\n -7782089449045308155\n -3891397775020389545\n -8635887519967615834\n  2567657390720808442\n                    ⋮\n  -827700957798788707\n  8695873654250506883\n  -632383545035102320\n -3765759921985883691\n -7663990578588859102\n -4983413334628357718\n  2162716648522859993\n -4384445303200905821\n -5180820757449774745\n  1006401675046291407\n -6620831146761193920\n  -783369668877822295\n\n\n\nhornertimed(x, coefbig)\n\n  0.000002 seconds (1 allocation: 16 bytes)\n\n\n7903279060725740955\n\n\n\npolyevaltimed(x, coefbig)\n\n  0.000036 seconds (1 allocation: 7.938 KiB)\n\n\n7903279060725740955\n\n\nHorner’s algorithm starts to become significantly faster when \\(n\\) is large. In this example, \\(n=1000\\) speeds up the computation by over an order of magnitude.\nAs a final note, let’s execute the slower method again on the polynomial of order \\(n\\), but this time let’s do it outside of a precompiled function:\n\n@time dot(coefbig, [x^(i-1) for i in 1:length(coefbig)])\n\n  0.032951 seconds (61.59 k allocations: 3.249 MiB, 86.29% compilation time)\n\n\n7903279060725740955\n\n\nThat’s way slower. The lesson here is to define functions. Especially if you are going to be doing the same operation more than once. This will keep Julia from wasting time compiling the same code over and over again.\nAs a final, final note, Horner’s algorithm suffers from one problem that may give the original formulation the upper hand: it cannot be multithreaded. In Horner’s algorithm, the computations must be performed sequentially, as the output of each step is used as input to the next. In contrast, in the original formulation each exponentiation can be done independently, then each multiplication, and finally the additions. I may make a separate post exploring this possibility in the future."
  },
  {
    "objectID": "blog/index.html",
    "href": "blog/index.html",
    "title": "Blog",
    "section": "",
    "text": "I don’t expect this to be updated frequently, but I thought I would include some blog posts here about some of the data work and other analysis I’ve done.\n\n\n\n\n\n\n\n\n\n\nIdentifying Counties that Contain the St. Andrews Bay Watershed\n\n\n\n\n\n\n\ngis\n\n\npython\n\n\nanalysis\n\n\n\n\nSome simple GIS with Python\n\n\n\n\n \n\n\n\n\n\n\nNumerical Methods in Economics AKA the Horner Algorithm\n\n\n\n\n\n\n\nnumerical methods\n\n\njulia\n\n\n\n\nA lesson in rewriting a computational problem.\n\n\n\n\n \n\n\n\n\nNo matching items"
  }
]